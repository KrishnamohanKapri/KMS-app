/**
 * KMS - Kitchen Management System API
 *
 * Contact: anas-ur-rasheed.abid@tu-ilmenau.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { ApiResponse } from '../model/apiResponse';
// @ts-ignore
import { Category } from '../model/category';
// @ts-ignore
import { CategoryCreate } from '../model/categoryCreate';
// @ts-ignore
import { CategoryResponse } from '../model/categoryResponse';
// @ts-ignore
import { CategoryUpdate } from '../model/categoryUpdate';
// @ts-ignore
import { ErrorResponse } from '../model/errorResponse';
// @ts-ignore
import { MealsGet200Response } from '../model/mealsGet200Response';
// @ts-ignore
import { MealsMealIdGet200Response } from '../model/mealsMealIdGet200Response';
// @ts-ignore
import { MealsMealIdPut200Response } from '../model/mealsMealIdPut200Response';
// @ts-ignore
import { ValidationError } from '../model/validationError';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class MealsApi extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Get all meal categories
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsCategoryGetGet(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<Array<Category>>;
    public mealsCategoryGetGet(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<Category>>>;
    public mealsCategoryGetGet(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<Category>>>;
    public mealsCategoryGetGet(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/category/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<Category>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete meal category
     * @param id 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsCategoryIdDelete(id: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public mealsCategoryIdDelete(id: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public mealsCategoryIdDelete(id: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public mealsCategoryIdDelete(id: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling mealsCategoryIdDelete.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (bearerAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('bearerAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/category/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update meal category
     * @param id 
     * @param categoryUpdate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsCategoryIdPut(id: string, categoryUpdate: CategoryUpdate, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CategoryResponse>;
    public mealsCategoryIdPut(id: string, categoryUpdate: CategoryUpdate, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CategoryResponse>>;
    public mealsCategoryIdPut(id: string, categoryUpdate: CategoryUpdate, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CategoryResponse>>;
    public mealsCategoryIdPut(id: string, categoryUpdate: CategoryUpdate, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling mealsCategoryIdPut.');
        }
        if (categoryUpdate === null || categoryUpdate === undefined) {
            throw new Error('Required parameter categoryUpdate was null or undefined when calling mealsCategoryIdPut.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (bearerAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('bearerAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/category/${this.configuration.encodeParam({name: "id", value: id, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<CategoryResponse>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: categoryUpdate,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create meal category
     * @param categoryCreate 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsCategoryPost(categoryCreate: CategoryCreate, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<CategoryResponse>;
    public mealsCategoryPost(categoryCreate: CategoryCreate, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<CategoryResponse>>;
    public mealsCategoryPost(categoryCreate: CategoryCreate, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<CategoryResponse>>;
    public mealsCategoryPost(categoryCreate: CategoryCreate, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (categoryCreate === null || categoryCreate === undefined) {
            throw new Error('Required parameter categoryCreate was null or undefined when calling mealsCategoryPost.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (bearerAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('bearerAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/category`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<CategoryResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: categoryCreate,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all meals with pagination and filters
     * Retrieve all active meals with search, category filtering, and pagination.
     * @param page Page number for pagination
     * @param limit Number of meals per page
     * @param mealType Type of meal type
     * @param search Search meals by title
     * @param category Filter by category ID or \&#39;all\&#39; for all categories
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsGet(page?: number, limit?: number, mealType?: 'breakfast' | 'lunch' | 'dinner', search?: string, category?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MealsGet200Response>;
    public mealsGet(page?: number, limit?: number, mealType?: 'breakfast' | 'lunch' | 'dinner', search?: string, category?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MealsGet200Response>>;
    public mealsGet(page?: number, limit?: number, mealType?: 'breakfast' | 'lunch' | 'dinner', search?: string, category?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MealsGet200Response>>;
    public mealsGet(page?: number, limit?: number, mealType?: 'breakfast' | 'lunch' | 'dinner', search?: string, category?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>page, 'page');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>limit, 'limit');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>mealType, 'mealType');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>search, 'search');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>category, 'category');

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<MealsGet200Response>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete meal
     * @param mealId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsMealIdDelete(mealId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public mealsMealIdDelete(mealId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public mealsMealIdDelete(mealId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public mealsMealIdDelete(mealId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (mealId === null || mealId === undefined) {
            throw new Error('Required parameter mealId was null or undefined when calling mealsMealIdDelete.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (bearerAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('bearerAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/${this.configuration.encodeParam({name: "mealId", value: mealId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get meal by ID
     * Retrieve a specific meal with all related data and availability information
     * @param mealId Meal ID
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsMealIdGet(mealId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MealsMealIdGet200Response>;
    public mealsMealIdGet(mealId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MealsMealIdGet200Response>>;
    public mealsMealIdGet(mealId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MealsMealIdGet200Response>>;
    public mealsMealIdGet(mealId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (mealId === null || mealId === undefined) {
            throw new Error('Required parameter mealId was null or undefined when calling mealsMealIdGet.');
        }

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/${this.configuration.encodeParam({name: "mealId", value: mealId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<MealsMealIdGet200Response>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update meal
     * Update meal information including images, ingredients, and tags
     * @param mealId Meal ID
     * @param title 
     * @param description Meal description
     * @param servings Number of servings this meal provides
     * @param price Price per serving
     * @param stock Available stock quantity
     * @param cookTime Time needed to cook the meal
     * @param servingEnd Time when the serving for the meal ends
     * @param servingStart Time when the serving for the meal starts
     * @param mealType Type of meal time
     * @param discount Discount percentage
     * @param category Category ID
     * @param tags JSON string array of tag names. Must be valid JSON format with double quotes.
     * @param ingredients Array of ingredient names. Can be sent as array of strings or JSON string array. If using JSON string, must be valid JSON format with double quotes (e.g., \\\&#39;[\\\&quot;chicken breast\\\&quot;, \\\&quot;olive oil\\\&quot;]\\\&#39;). Default quantity of 50g per serving will be used unless ingredientQuantities and ingredientUnits are provided.
     * @param ingredientQuantities Array of ingredient quantities per serving. Can be sent as array of numbers or JSON string array. Must match the order of ingredients array. If not provided, default quantity of 50g per serving will be used.
     * @param ingredientUnits Array of ingredient units. Can be sent as array of strings or JSON string array. Must match the order of ingredients array. If not provided, default unit of \\\&#39;g\\\&#39; will be used.
     * @param allergens JSON string array of allergen names. Must be valid JSON format with double quotes.
     * @param previousImages JSON string array of existing image paths. Must be valid JSON format with double quotes.
     * @param images New image file(s) for the meal. Multiple images can be uploaded by selecting multiple files.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsMealIdPut(mealId: string, title?: string, description?: string, servings?: number, price?: number, stock?: number, cookTime?: number, servingEnd?: string, servingStart?: string, mealType?: string, discount?: number, category?: string, tags?: string, ingredients?: string, ingredientQuantities?: string, ingredientUnits?: string, allergens?: string, previousImages?: string, images?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<MealsMealIdPut200Response>;
    public mealsMealIdPut(mealId: string, title?: string, description?: string, servings?: number, price?: number, stock?: number, cookTime?: number, servingEnd?: string, servingStart?: string, mealType?: string, discount?: number, category?: string, tags?: string, ingredients?: string, ingredientQuantities?: string, ingredientUnits?: string, allergens?: string, previousImages?: string, images?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MealsMealIdPut200Response>>;
    public mealsMealIdPut(mealId: string, title?: string, description?: string, servings?: number, price?: number, stock?: number, cookTime?: number, servingEnd?: string, servingStart?: string, mealType?: string, discount?: number, category?: string, tags?: string, ingredients?: string, ingredientQuantities?: string, ingredientUnits?: string, allergens?: string, previousImages?: string, images?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MealsMealIdPut200Response>>;
    public mealsMealIdPut(mealId: string, title?: string, description?: string, servings?: number, price?: number, stock?: number, cookTime?: number, servingEnd?: string, servingStart?: string, mealType?: string, discount?: number, category?: string, tags?: string, ingredients?: string, ingredientQuantities?: string, ingredientUnits?: string, allergens?: string, previousImages?: string, images?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (mealId === null || mealId === undefined) {
            throw new Error('Required parameter mealId was null or undefined when calling mealsMealIdPut.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (bearerAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('bearerAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        localVarUseForm = canConsumeForm;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (title !== undefined) {
            localVarFormParams = localVarFormParams.append('title', <any>title) as any || localVarFormParams;
        }
        if (description !== undefined) {
            localVarFormParams = localVarFormParams.append('description', <any>description) as any || localVarFormParams;
        }
        if (servings !== undefined) {
            localVarFormParams = localVarFormParams.append('servings', <any>servings) as any || localVarFormParams;
        }
        if (price !== undefined) {
            localVarFormParams = localVarFormParams.append('price', <any>price) as any || localVarFormParams;
        }
        if (stock !== undefined) {
            localVarFormParams = localVarFormParams.append('stock', <any>stock) as any || localVarFormParams;
        }
        if (cookTime !== undefined) {
            localVarFormParams = localVarFormParams.append('cookTime', <any>cookTime) as any || localVarFormParams;
        }
        if (servingEnd !== undefined) {
            localVarFormParams = localVarFormParams.append('servingEnd', <any>servingEnd) as any || localVarFormParams;
        }
        if (servingStart !== undefined) {
            localVarFormParams = localVarFormParams.append('servingStart', <any>servingStart) as any || localVarFormParams;
        }
        if (mealType !== undefined) {
            localVarFormParams = localVarFormParams.append('mealType', <any>mealType) as any || localVarFormParams;
        }
        if (discount !== undefined) {
            localVarFormParams = localVarFormParams.append('discount', <any>discount) as any || localVarFormParams;
        }
        if (category !== undefined) {
            localVarFormParams = localVarFormParams.append('category', <any>category) as any || localVarFormParams;
        }
        if (tags !== undefined) {
            localVarFormParams = localVarFormParams.append('tags', <any>tags) as any || localVarFormParams;
        }
        if (ingredients !== undefined) {
            localVarFormParams = localVarFormParams.append('ingredients', <any>ingredients) as any || localVarFormParams;
        }
        if (ingredientQuantities !== undefined) {
            localVarFormParams = localVarFormParams.append('ingredientQuantities', <any>ingredientQuantities) as any || localVarFormParams;
        }
        if (ingredientUnits !== undefined) {
            localVarFormParams = localVarFormParams.append('ingredientUnits', <any>ingredientUnits) as any || localVarFormParams;
        }
        if (allergens !== undefined) {
            localVarFormParams = localVarFormParams.append('allergens', <any>allergens) as any || localVarFormParams;
        }
        if (previousImages !== undefined) {
            localVarFormParams = localVarFormParams.append('previousImages', <any>previousImages) as any || localVarFormParams;
        }
        if (images !== undefined) {
            localVarFormParams = localVarFormParams.append('images', <any>images) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals/${this.configuration.encodeParam({name: "mealId", value: mealId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<MealsMealIdPut200Response>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a new meal
     * Create a new meal with images, ingredients, allergens, and tags
     * @param title Meal title
     * @param description Meal description
     * @param servings Number of servings this meal provides
     * @param cookTime Time needed to cook the meal
     * @param servingEnd Time when the serving for the meal ends
     * @param servingStart Time when the serving for the meal starts
     * @param mealType Type of meal time
     * @param price Price per serving
     * @param category Category ID
     * @param tags JSON string array of tag names. Must be valid JSON format with double quotes.
     * @param ingredients Array of ingredient names. Can be sent as array of strings or JSON string array. If using JSON string, must be valid JSON format with double quotes (e.g., \\\&#39;[\\\&quot;chicken breast\\\&quot;, \\\&quot;olive oil\\\&quot;]\\\&#39;). Default quantity of 50g per serving will be used unless ingredientQuantities and ingredientUnits are provided.
     * @param allergens JSON string array of allergen names. Must be valid JSON format with double quotes.
     * @param ingredientQuantities Array of ingredient quantities per serving. Can be sent as array of numbers or JSON string array. Must match the order of ingredients array. If not provided, default quantity of 50g per serving will be used.
     * @param ingredientUnits Array of ingredient units. Can be sent as array of strings or JSON string array. Must match the order of ingredients array. If not provided, default unit of \\\&#39;g\\\&#39; will be used.
     * @param mealImage Single image file for the meal. Supports JPG, PNG, WebP, GIF formats up to 10MB.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public mealsPost(title: string, description: string, servings: number, cookTime: number, servingEnd: string, servingStart: string, mealType: string, price: number, category: string, tags: string, ingredients: string, allergens: string, ingredientQuantities?: string, ingredientUnits?: string, mealImage?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ApiResponse>;
    public mealsPost(title: string, description: string, servings: number, cookTime: number, servingEnd: string, servingStart: string, mealType: string, price: number, category: string, tags: string, ingredients: string, allergens: string, ingredientQuantities?: string, ingredientUnits?: string, mealImage?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ApiResponse>>;
    public mealsPost(title: string, description: string, servings: number, cookTime: number, servingEnd: string, servingStart: string, mealType: string, price: number, category: string, tags: string, ingredients: string, allergens: string, ingredientQuantities?: string, ingredientUnits?: string, mealImage?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ApiResponse>>;
    public mealsPost(title: string, description: string, servings: number, cookTime: number, servingEnd: string, servingStart: string, mealType: string, price: number, category: string, tags: string, ingredients: string, allergens: string, ingredientQuantities?: string, ingredientUnits?: string, mealImage?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling mealsPost.');
        }
        if (description === null || description === undefined) {
            throw new Error('Required parameter description was null or undefined when calling mealsPost.');
        }
        if (servings === null || servings === undefined) {
            throw new Error('Required parameter servings was null or undefined when calling mealsPost.');
        }
        if (cookTime === null || cookTime === undefined) {
            throw new Error('Required parameter cookTime was null or undefined when calling mealsPost.');
        }
        if (servingEnd === null || servingEnd === undefined) {
            throw new Error('Required parameter servingEnd was null or undefined when calling mealsPost.');
        }
        if (servingStart === null || servingStart === undefined) {
            throw new Error('Required parameter servingStart was null or undefined when calling mealsPost.');
        }
        if (mealType === null || mealType === undefined) {
            throw new Error('Required parameter mealType was null or undefined when calling mealsPost.');
        }
        if (price === null || price === undefined) {
            throw new Error('Required parameter price was null or undefined when calling mealsPost.');
        }
        if (category === null || category === undefined) {
            throw new Error('Required parameter category was null or undefined when calling mealsPost.');
        }
        if (tags === null || tags === undefined) {
            throw new Error('Required parameter tags was null or undefined when calling mealsPost.');
        }
        if (ingredients === null || ingredients === undefined) {
            throw new Error('Required parameter ingredients was null or undefined when calling mealsPost.');
        }
        if (allergens === null || allergens === undefined) {
            throw new Error('Required parameter allergens was null or undefined when calling mealsPost.');
        }

        let localVarHeaders = this.defaultHeaders;

        // authentication (bearerAuth) required
        localVarHeaders = this.configuration.addCredentialToHeaders('bearerAuth', 'Authorization', localVarHeaders, 'Bearer ');

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        localVarUseForm = canConsumeForm;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (title !== undefined) {
            localVarFormParams = localVarFormParams.append('title', <any>title) as any || localVarFormParams;
        }
        if (description !== undefined) {
            localVarFormParams = localVarFormParams.append('description', <any>description) as any || localVarFormParams;
        }
        if (servings !== undefined) {
            localVarFormParams = localVarFormParams.append('servings', <any>servings) as any || localVarFormParams;
        }
        if (cookTime !== undefined) {
            localVarFormParams = localVarFormParams.append('cookTime', <any>cookTime) as any || localVarFormParams;
        }
        if (servingEnd !== undefined) {
            localVarFormParams = localVarFormParams.append('servingEnd', <any>servingEnd) as any || localVarFormParams;
        }
        if (servingStart !== undefined) {
            localVarFormParams = localVarFormParams.append('servingStart', <any>servingStart) as any || localVarFormParams;
        }
        if (mealType !== undefined) {
            localVarFormParams = localVarFormParams.append('mealType', <any>mealType) as any || localVarFormParams;
        }
        if (price !== undefined) {
            localVarFormParams = localVarFormParams.append('price', <any>price) as any || localVarFormParams;
        }
        if (category !== undefined) {
            localVarFormParams = localVarFormParams.append('category', <any>category) as any || localVarFormParams;
        }
        if (tags !== undefined) {
            localVarFormParams = localVarFormParams.append('tags', <any>tags) as any || localVarFormParams;
        }
        if (ingredients !== undefined) {
            localVarFormParams = localVarFormParams.append('ingredients', <any>ingredients) as any || localVarFormParams;
        }
        if (ingredientQuantities !== undefined) {
            localVarFormParams = localVarFormParams.append('ingredientQuantities', <any>ingredientQuantities) as any || localVarFormParams;
        }
        if (ingredientUnits !== undefined) {
            localVarFormParams = localVarFormParams.append('ingredientUnits', <any>ingredientUnits) as any || localVarFormParams;
        }
        if (allergens !== undefined) {
            localVarFormParams = localVarFormParams.append('allergens', <any>allergens) as any || localVarFormParams;
        }
        if (mealImage !== undefined) {
            localVarFormParams = localVarFormParams.append('mealImage', <any>mealImage) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/meals`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ApiResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
